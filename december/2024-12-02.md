# TIL Template

## 날짜: 2024-12-02

### 스크럼
- 학습 목표 1 : 운영체제


### 새로 배운 내용
#### 주제 1: 운영체제

### 메모리
- cpu는 그저 메모리 에 올라와 있는 프로그램을 실행할 뿐이다.

### 메모리 계층
- 레지스터 (속도 1등, 용량 꼴등, 비쌈)
- 캐시(L1, L2)
- 메모리 (RAM) / 주 기억 장치
- 저장 장치(SSD, HDD) / 보조 기억 장치 (속도 꼴등, 용량 1등, 쌈)
> 게임에서 로딩 중이라는 문구가 보이는 것은 HDD(하드 디스크) 또는 인터넷에서 데이터를 RAM으로 읽어오지 못한 것

### 캐시
- 데이터 임시 저장소
- 레지스터 - RAM 간 데이터 속도 차이로 인한 병목현상을 줄이기 위한 메모리 


### 지역성의 원리
- 시간 지역성: 최근 사용한 데이터 접근
- 공간 지역성: 최근 접근한 데이터의 가장 가까운 공간에 접근

### 캐시 히트

- 캐시에서 원하는 데이터 찾는 것 / 제어 장치를 거쳐 가져오기 때문에 빠르다

### 캐시 미스

- 캐시에 데이터가 없다면 RAM으로 가서 데이터를 찾아오는 것 / 메모리에 가야하는데 시스템 버스 거쳐 느리다

### 캐시 매핑
- 캐시 히트 되기 위해 캐시-메모리 간 매핑 하는 방법.
### 직접 매핑 
- 메모리 1~100 있고 캐시 1~10이라면 1:1~10 2:1~20 같은 방식의 매핑. 처리가 빠르지만 충돌 발생이 잦다
### 연관 매핑 
- 순서 없이 관련 있는 캐시와 메모리 매핑. 속도가 느리다.

### 집합 연관 매핑 
- 직접 + 연관 / 효율적

### 쿠키

- 만료 기간이 있는 키-밸류 저장소
- 4kb 까지 데이터 저장


### 로컬 스토리지

- 만료 기간이 없는 키-밸류 저장소
- 5mb
- 웹 브라우저 닫아도 유지

### 세션 스토리지

- 만료 기간이 없는 키-밸류 저장소
- 5mb
- 웹 브라우저 닫으면 사라짐

### 메모리 관리
#### 가상 메모리

- 메모리 관리 기법 중 하나. 컴퓨터가 이용 가능한 메모리 자원을 추상화 하여 큰 메모리로 보이게 하는 것

- 가상 주소(logical address): 가상적으로 주어진 주소
- 실제 주소(pyhsical address): 실제 메모리 상 주소

#### 스와핑

- 페이지 폴트 발생 시 미 사용하는 공간 (RAM)<-> 남는 공간(HDD)

#### 페이지 폴트

- 가상 메모리 주소에는 있지만 실제 RAM에는 없을 때 발생

#### 페이지 
- 가상 메모리 사용 최소 단위

- 프레임 : 실제 메모리 사용 최소 단위

#### 스레싱

- 페이지 폴트 율이 높은 것 -> CPU 상승 -> 성능 저하

#### 해결 방법
1. 메모리 늘리거나

2. HDD->SDD 교체

#### 작업세트
- 지역성의 원리를 통해 결정된 페이지 집합을 미리 로드


#### PFF
- 페이지 폴트 상, 하한선을 만들어 만약 도달할 시 프레임 증가, 감소

#### 메모리 할당

- RAM에 프로그램 올리는 행위

> 연속 할당

- 연속적으로 메모리에 프로그램 할당
- 고정 분할 : 미리 메모리 공간을 나누어 할당. 내부 단편화 O
- 가변 분할 : 동적으로 메모리 공간 할당. 내부 단편화 X, 외부 단편화 O
- 
- 최초 적합: 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당
- 최적 적합: 프로세스 크기가 이상적인 공간 중 가장 작은 홀에 할당
- 최악 적합: 프로세스 크기와 홀 크기가 가장 차이 많이 나는 공간에 할당
-
- 내부 단편화: 메모리를 나눈 공간보다 프로그램이 작아서 들어가지 못하는 현상
- 외부 단편화: 메모리를 나눈 공간보다 프로그램이 커서 들어가지 못하는 현상

- 홀: 비어있는 메모리 공간

> 불연속 할당 = 페이징 기법
-  현대 운영체제가 사용

#### 페이징
- 동일한 크기의 페이지로 나누어 메모리 서로 다른 위치에 프로세스 할당
#### 세그먼트
- 동일한 크기의 세그먼트로 나누어 메모리 서로 다른 위치에 프로세스 할당 / 홀 규격이 일정하지 않은 단점
#### 페이지드 세그멘테이션
- 프로그램->세그먼트로 나누고 동일한 크기의 페이지로 나누는 것
#### 페이지 교체 알고리즘
- 스와핑이 일어나는 방식

#### 오프라인 알고리즘
#### FIFO
#### LRU(Least Recently Used)
- 참조가 가장 오래된 페이지를 바꿈 / 참조 시 스택 top 에 다시 쌓임
#### NUR(NOT Used Recently) = clock 알고리즘
- 0 은 참조되지 않음, 1 참조됨
- 시계방향으로 돌며 0이 나올 시 프로세스 교체
#### LFU(Least Frequently Used)
- 가장 참조 횟수가 적은 페이지를 교체

### 오늘의 회고
- 시스템 내부적 으로 어떤 동작을 하는지 알게 되었다

